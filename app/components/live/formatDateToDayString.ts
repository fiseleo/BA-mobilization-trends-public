import type { RaidInfo } from "~/types/data";

export const formatDateToDayString = (dateInput: Date | string, raidInfo: RaidInfo): string => {
  // 1. Sets the base start date as the KST base.
  const dateStr = (new Date(raidInfo.Date)).toISOString().split('T')[0]
  // const baseDate = new Date('2025-10-15T00:00:00+09:00');
  const baseDate = new Date(`${dateStr}T00:00:00+09:00`);
  const initialDate = new Date(dateInput);

  // 2. Extract each time element of the entered date as a number based on the KST time zone.
  const kstParts = new Intl.DateTimeFormat('en-CA', {
    timeZone: 'Asia/Seoul',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  }).formatToParts(initialDate).reduce((acc, part) => {
    if (part.type !== 'literal') {
      acc[part.type] = Number(part.value);
    }
    return acc;
  }, {} as Record<string, number>);

  // 3. Round the minutes in 10-minute increments.
  const roundedMinutes = Math.floor(kstParts.minute / 10) * 10;

  // 4. Create a new Date object by applying the rounded minutes.
  //    When 55 minutes is rounded to 60 minutes, the time automatically moves on to the next time.
  const finalDate = new Date(Date.UTC(
    kstParts.year,
    kstParts.month - 1, // month starts from 0
    kstParts.day,
    kstParts.hour,
    roundedMinutes
  ));
  // Subtract the KST offset (9 hours) from the time generated by UTC to adjust to the KST time.
  finalDate.setHours(finalDate.getHours() - 9);

  // 5. Calculates the day and time based on the last adjusted date.
  const diffInMillis = finalDate.getTime() - baseDate.getTime();
  const dayNumber = Math.floor(diffInMillis / 86400000) + 1;

  const formattedTime = new Intl.DateTimeFormat('en-CA', {
    timeZone: 'Asia/Seoul',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  }).format(finalDate);

  // 6.Returns in final format in combination.
  return `Day${dayNumber} ${formattedTime}`;
};